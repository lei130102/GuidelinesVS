using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;

//在过去，Windows开发人员必须在方便性和灵活性之间做出选择。为得到最大的方便性，他们可以使用预选构建好的控件。这些控件可以工作得很好，但可定制性十分有限，并且几乎总是具有
//固定的可视化外观。偶尔，某些控件提供了不很直观的“自主绘图”模式，允许开发人员通过响应回调来绘制控件的一部分。但基本控件——按钮、文本框、复选框和列表框等——被完全锁定了
//因此，希望实现一些更特殊效果的开发人员不得不从头构建自定义控件。这确实是一个问题——手工编写绘图逻辑不但非常费时而且很困难，但自定义控件开发人员还需要从头实现基本功能
//(例如，在文本框中选择文本以及在按钮中处理按键)。并且，即使自定义控件是完美的，将他们插入到已有应用程序中也需要进行一些重要的修改，通常需要修改代码(并且还需要进行更多的测试)
//简单地说，自定义控件是必需的内容——他们是实现新颖时髦的用户界面的唯一方法，但支持他们并将他们集成到应用程序中也是一件棘手的事情

//WPF最终通过样式以及模板解决了控件的自定义问题。这些特性能够很好地工作地原因是，在WPF中控件的实现方式发生了重大变化。在以前的用户界面技术(如Windows窗体)中常用的控件实际上
//不是由.NET代码实现的。相反，Windows窗体控件类封装了来自Win32 API的核心要素，他们是不能改变的。但正如前面所学的，WPF中的每个控件是由纯粹的.NET代码构成的，其背后没有使用
//任何Win32 API。因此，WPF能够提供一种机制(样式和模板)，允许您进入这些元素的内部并彻底重新设计他们

namespace WPF_ControlTemplate
{
    /// <summary>
    /// App.xaml 的交互逻辑
    /// </summary>
    public partial class App : Application
    {
    }
}
